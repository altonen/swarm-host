diff --git a/framework/core.py b/framework/core.py
index 709fea8..d870b3d 100644
--- a/framework/core.py
+++ b/framework/core.py
@@ -20,6 +20,12 @@ def setup_nodes():
 def run_test():
     print("run test")
 
+# block response handler
+def handle_block_response(ctx, dst_iface, src_peer, dst_iface, dst_peer, response):
+    if response != None:
+        return Forward
+    return Timeout
+
 def main():
     print("initializing test program")
     host = SwarmHost(8884, "mockchain")
diff --git a/src/backend/mod.rs b/src/backend/mod.rs
index c50231f..6e25115 100644
--- a/src/backend/mod.rs
+++ b/src/backend/mod.rs
@@ -144,6 +144,39 @@ pub trait Interface<T: NetworkBackend> {
     fn disconnect(&mut self, peer: T::PeerId) -> crate::Result<()>;
 }
 
+pub trait Newtest {
+    type Notification;
+    type Request;
+    type Response;
+}
+
+pub enum MessageType<T: Newtest> {
+    Notification(T::Notification),
+    Request(T::Request),
+    Response(T::Response),
+}
+
+#[async_trait::async_trait]
+pub trait PacketSinkNew<T: NetworkBackend>: Debug {
+    async fn send_packet(
+        &mut self,
+        protocol: Option<T::Protocol>,
+        message: &T::Message,
+    ) -> crate::Result<()>;
+
+    async fn send_request(
+        &mut self,
+        protocol: T::Protocol,
+        message: &T::Request,
+    ) -> crate::Result<()>;
+
+    async fn send_response(
+        &mut self,
+        protocol: T::Protocol,
+        message: &T::Response,
+    ) -> crate::Result<()>;
+}
+
 /// Traits which each network backend must implement.
 #[async_trait::async_trait]
 pub trait NetworkBackend {
diff --git a/src/backend/substrate/network/src/protocol/notifications/handler.rs b/src/backend/substrate/network/src/protocol/notifications/handler.rs
index 0daadca..ded1ab4 100644
--- a/src/backend/substrate/network/src/protocol/notifications/handler.rs
+++ b/src/backend/substrate/network/src/protocol/notifications/handler.rs
@@ -554,6 +554,9 @@ impl ConnectionHandler for NotifsHandler {
                             return;
                         }
 
+                        // TODO: check if the interface is already bound and use the handshake
+                        // of the bound node. If no binding has occurred yet, echo back the
+                        // received handshake and save it for later use.
                         log::info!(
                             target: "sub-libp2p",
                             "`Opening`/`Open`: echo back the same handshake",
diff --git a/src/overseer.rs b/src/overseer.rs
index 4743d54..edb8307 100644
--- a/src/overseer.rs
+++ b/src/overseer.rs
@@ -239,6 +239,27 @@ impl<T: NetworkBackend + Debug> Overseer<T> {
                             "message received from peer"
                         );
 
+                        enum RequestHandlingResult {
+                            Timeout,
+                            Reject,
+                            Empty,
+                            Forward,
+                            SendBack(T::Request),
+                        }
+
+                        enum ResponseHandlingResult {
+                            Timeout,
+                            Reject,
+                            Forward,
+                            SendBack(T::Response),
+                        }
+
+                        match message_type {
+                            MessageType::Notification(_notification) => todo!(),
+                            MessageType::Request(_request) => todo!(),
+                            MessageType::Response(_response) => todo!(),
+                        }
+
                         match self.filter.inject_message(
                             interface,
                             peer,
